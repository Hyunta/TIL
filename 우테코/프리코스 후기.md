# 우아한 테크코스 프리코스 회고



## 1. 과정 소개

프리코스는 우아한 테크코스를 진행하기에 앞서 자격을 확인하기 위한 과정이다. 1차 심사 자기소개서와 코딩테스트를 통과해야지 참가할 수 있다. 3기 기준으로 대략 1천명이 지원했다고 했는데, 4기는 아직 전체 지원자수는 모르지만 현재 프리코스를 진행중인 백엔드 지원자들은 160명 가량된다. 선발 인원이 100명이므로 대략 1.6:1의 경쟁률이다.

3주 동안 총 3개의 과제가 나오고 매주 수요일 15시부터 일주일동안 구현해서 제출하면 된다. 매주 미션이 시작될 때 메일을 통해서 제출이 잘 됐는지 확인해주고 공통 피드백을 보내준다. 매주 미션의 난이도가 어려워지고, 조건들이 추가된다.



## 2. 프리코스 이전 나의 상태

중학교 학생들을 대상으로 수학 수업을 구성하다 코딩에 흥미가 생겨서 개발자를 준비하게 되었고, 인공지능 국비교육을 수료한 뒤 백엔드에 흥미가 생겨서 Java와 Spring 공부를 1년정도 했다. 주로 인프런과 유튜브의 강의를 통해서 학습을 했고 Spring, JPA는 인프런에서 김영한 님 로드맵을 전부 수강했다. 객체 지향에 대해 공부하기 위해서 객체 지향에 대한 사실과 오해, TDD 책을 읽었고 NextStep PlayGround 과정을 통해 TDD 맛봤다. 프론트엔드 개발자인 친구와 TodoList 프로젝트를 진행하고, 중고 책 거래하는 사이트를 만들어보기 위해서 공부중인 상태에서 지원하게 되었다.

Java를 정통으로 공부한게 아니라, 필요할 때 마다 구글링해가면서 학습했기 때문에 자신은 없었다. 1차 심사를 합격하고 나서 프리코스 1주차 문제를 구현해보려고 했는데 막막했었다. 함수를 어떻게 분리해야할지 감이 잘 안왔고, 클래스도 분리할 줄 몰랐다. 근데 코딩테스트를 준비하기 위해서 Java로 알고리즘 연습을 꾸준히 해왔기 때문에 Java가 완전 낯선상태는 아니었다.



---

## 3. 미션(1주차~3주차)

### 0주차(준비)

1차 심사 결과 메일을 받고나서, 프리코스를 진행하는 목적과 사전준비 라는 메일을 받았다.

![스크린샷 2021-12-12 오전 1.27.10](/Users/hyuntae/Desktop/스크린샷 2021-12-12 오전 1.27.10.png)

설레었다, 뭔가 프리코스가 본격적으로 시작되는 것 같은 기분을 받았다.

미션을 시작하기 전에 매우 설레는 상태로 과제에 임했다. 1차 심사에 합격을 하고나서 1주차 문제를 구현해봤다. 처음에는 알고리즘 풀듯이 main 메서드 안에 모든 기능을 구현했다. 돌이켜 생각해보면 3 주 동안 큰변화가 있었다.

### 1주차 과제(숫자 야구)

1주차 과제는 숫자 야구를 구현하는 과제였다. 주어진 미션은 함수를 분리해서 한가지 기능을 할 수 있도록 구현하는 것이었다. 아래는 구현하면서 고민했던 사항들을 정리해놨다.

---

1. 패키지 구조
2. 예외 처리
3. 클린코드?

---

#### 1. 패키지 구조

숫자야구 프로젝트를 진행하고 다른 분들의 코드를 읽어보다 패키지 구조를 어떻게 가져가는게 좋을까하는 고민을 하게되었다. 나는 기본적인 구조에서 constant 패키지만 생성해서 에러메시지와 입출력 메시지를 관리하는 Message클래스와 입력하는 숫자의 범위와 길이 등 규칙을 관리하는 Rule 클래스를 넣어두었다.

```
├─main
│  └─java
│      ├─baseball
│      └─constant
└─test
    └─java
        └─baseball
```

하지만 참가자들중 MVC 패턴을 이용해서 controller,domain,view 를 나누어서 진행하신 분들도 있었고 기능별로 나눠서 설계하신분도 있었다. 개인적으로 프로젝트 규모가 크지 않아서 굳이 나눠야하나 생각했는데 막상 나눠진 것을 봤을 때 깔끔하다는 생각이 들었다. 효율적인 구조에 대해 고민을 하다 구글링을 통해 패키지 구조에 대한 공부를 했다.

---

패키지 구조는 크게 계층 우선 구조, 모듈 우선 구조 두 가지로 나눌 수 있다.

##### 계층(layer) 우선

```java
net.slipp.domain.modulename
net.slipp.service.modulename
net.slipp.dao.modulename
net.slipp.web.modulename
```

특징: 도메인 모델 주도 개발에 적합하다.

장점: 각 패키지간의 cyclic dependency



##### 모듈(feature) 우선

```java
net.slipp.modulename.domain
net.slipp.modulename.service
net.slipp.modulename.dao
net.slipp.modulename.web
```

특징: 개발자별로 기능 단위 개발을 하는 경우 주로 발생한다.

장점: 모듈 단위로 분리할 때 유리하다.

---

찾아본 결과 정답은 없고 각자의 취향 혹은 팀원들의 규칙에 따라 가는 것 같다.

하지만 미션으로 나오는 과제들은 구현해야할 기능이 많지 않기 때문에 모듈 우선 구조로 설계하게되면 필요 이상으로 패키지가 많이 생기게된다. 따라서 계층 우선 구조로 설계를 하기로 결정하는게 좋을 것 같다.

MVC 패턴에 대해서 조금 생각해봐야겠다. 1주차는 구현해야 할 기능에 비해 구조가 과하다고 생각했는데 2주차 과제부터 도메인이 많아지거나 구조가 복잡해진다면 도입해볼 생각이다.

참고:

https://slipp.net/questions/36

 http://www.javapractices.com/topic/TopicAction.do?Id=205



#### 2. 예외처리

```java
public class Validation {
	public static void checkRestartInput(String request) {
		if (!request.equals("1") && !request.equals("2")) {
			throw new IllegalArgumentException(ERROR_REQUEST_INPUT);
		}
	}
```

위 코드는 1주차 숫자야구 미션에서 재시작 입력값을 예외처리한 메서드다.

>  "재시작을 원한다면 1을 입력하고, 종료를 원한다면 2를 입력해라."

불만족스러웠지만 다른 방법이 생각이 안나서 우선 1,2를 제외한 입력을 받았을 때  `IllegalArgumentException` 를 발생시키는 방법을 택했다. 그리고 클린코드 7장. 오류 처리를 통해 오류 코드보다는 예외를 사용하라는 도움을 받아 2주차 부터는 try-catch 구문으로 오류를 처리해보려고 한다.

#### 3. 클린코드?

큰 고민 사항은 위 두 항목이었지만, 사실 코드를 짜는 모든 과정에서 고민이 생겼다. 어떻게 하면 더 쉽게 읽힐 수 있을까? 어떻게 하면 구조가 한눈에 들어올까 고민을 했다. 도움을 얻기 위해 클린코드 책에서 필요한 부분들을 찾아서 읽고, 구조에 대한 고민이 시작됐다. 한 주 동안 코드를 모르는 사람이 봐도 내 코드를 이해할 수 있도록 간단하게 구현하려고 노력했고 매일매일 나아지는 것을 느꼈다. 클린코드를 읽으며 예외처리, 변수명에 대해서 고민했고, 함수가 한가지의 기능에 책임질 수 있도록 설계하려고 했다.

> 소프트웨어를 짜는 행위는 여느 글짓기와 비슷하다. 먼저 생각을 기록한 후 읽기 좋게 다듬는다. 초안은 대개 서투르고 어수선하므로 원하는 대로 읽힐 때까지 말을 다듬고 문장을 고치고 문단을 정리한다.

이 말이 나에게 와닿았다. 첫 과제라 기능 구현에서 큰 어려움은 없었지만 가독성이 있는 코드를 작성하기 위해 노력했다.

---

## 2주차 과제 (자동차 경주)

2주차 과제는 자동차 경주 게임 구현이었다. 주어진 미션은 클래스 분리였다. 아래는 구현하면서 고민했던 사항들이다.

---

1. 클래스 분리와 함수 분리
2. 예외 처리
3. 메세지, 상수
4. 책임에 대하여

---

## 1. 클래스 분리와 함수 분리

1주차를 마치고 같이 제출하신 분들의 코드를 읽어보았다. 구현을 해본 코드라서 다른 분들의 코드를 이해하기 쉬웠다. 정말 배울점이 많았고 그 중에 바로 도입해야겠다고 생각한 것이 패키지의 구조였다. 클린코드의 함수와 객체 부분을 읽으며 얼마나 분리해야하나 고민을 했는데, 답을 구할 수 있었다.

> 함수는 한 가지를 해야 한다. 그 한 가지를 잘해야 한다. 그 한가지 만을 해야한다.

최대한 작게 만들고 함수가 하나의 기능만을 하도록 만들라고 하였고, 이 말은 즉 단 한개의 책임을 가져야한다는 말이다. 책임이라는 말이 애매하기 때문에 저자는 변경이 있을 때 파급 효과가 적도록 구현하라고 하였다.

SOLID의 제일 앞글자를 담당하는 Single Responsibility Principle(단일 책임 원칙) 을 지키며 구현하는 것이 나의 2주차 목표였다.

처음 난간에 봉착한 것은 자동차 이름 입력값을 검증하는 과정에서 였다. 

> 1. 입력값을 받는다.
> 2. 입력값이 조건에 부합한지 판단한다.
> 3. 조건에 부합하면 `ArrayList<String>` 를 반환한다.

Controller 에서 이 3가지 기능이 한번에 움직이길 바랐다. 그러다 보니 처음 구현을 했을 때 책임이 중구난방 뒤섞여있었다. 그런데 클린코드에서 변수명을 잘 지으면 문제를 해결할 실마리가 보인다해서 고민을 했다.

결과적으로, 나는 getProperName 이라는 함수명을 통해 검증은 nameValidator에게 책임을 위임하고 입력값을 갖고오는 책임을 InputView에 부여하고 Controller에게는 입력값에 관해 받아오기만 하면 되도록 설계했다.

클래스를 잘 분리하기 위해서 MVC 패턴을 도입해보려고 노력하고, 클래스 이름을 잘 지어보려고 했다. 처음에는 CarService를 이용해서 각 경기를 진행하고, 자동차 등록, 우승자를 찾아내는 기능들을 관리했었다. 하지만 조금 더 깔끔하게 관리를 하고 싶어서 찾아보다가 일급 클래스에 대해 찾아보게 되었다.

바로 이거다 싶어서 Cars 라는 객체를 만들고 경주에 관련된 메서드를 관리하도록 만들었더니 Controller에서 더 명확하게 어떤 일을 하는지 확인할 수 있었다.

reference:

https://jojoldu.tistory.com/412

---

## 2. 예외 처리

예외 처리에 관련된 부분도 클린코드에서 도움을 받을 수 있었다.

1주차에는 needBalls 라는 `boolean` 값을 flag 값으로 사용해서 while-do 구문을 이용했다. 그런데 이보다 try-catch 구문을 쓰는게 더 명확하고 깔끔하다는 내용을 보았다.

그래서 2주차에서는 예외처리를 validation 클래스를 생성하여 `boolean` 값을 return 하는 것이 아니라 예외를 발생시키고 예외를 InputView클래스에서 catch 해서 풀어갈 수 있도록 구현해보았다.

```java
public void validateNames(ArrayList<String> names) {
		isOnlyName(names);
    	...
	}

	private void isOnlyName(ArrayList<String> names) {
		if (names.size() == 1) {
			throw new IllegalArgumentException(ERROR_ONLY_NAME);
		}
	}
```

---

## 3. 메세지 상수 처리

1주차 때는 constant 패키지를 만들어서 오류 메세지, 출력 메세지, 상수를 한꺼번에 관리하는 클래스를 만들었었다. 다른 분들은 view 클래스를 만들어서 한번에 입출력을 관리하도록 구현했는데 이 방식이 깔끔해보였다. 메세지도 상단에서 바로 확인할 수 있고 입력과 출력을 클래스를 통해 구분할 수 있어서 좋아보였다.

상수를 따로 분리하는 것도 나쁘지는 않다고 생각하는데, 이번에는 입출력을 관리하는 클래스를 만들어서 구현하기로 했다.

----

## 4. 책임에 대하여

구현을 마치고 계속 리팩토링하면서 책임에 대한 부분이 고민이 많이 됐다. 단일 책임 원칙을 지키고 싶은데, 책임이라는 말도 모호하고 한가지라고 보는 관점이 다를 수 있어서 클린코드의 클래스, 함수 챕터를 여러번 반복해서 읽었다. 최대한 의미있게 클래스를 분리하고 싶어서 각 클래스가 하나의 책임을 가질 수 있도록 설계했다.

```
Car : 도메인 자동차 객체
CarService : 자동차 객체의 로직
RaceController : 애플리케이션 흐름 제어
InputView : 입력 관리
OutputView : 출력 관리
NameValidator : 이름 목록 검증
MoveCountValidator : 이동 횟수 검증
```

작성을 하고보니 CarService의 책임이 하나 이상이라고 봐야하나 의문이 든다. Controller와 Service를 조금 더 깔끔하게 구분하고 싶은데 아직까지는 방법을 잘 모르겠다. Car 객체를 다루는 방법도 서툴고 getter를 만들어서 접근할 수 있도록 만들기보다 좀 더 나은 방법은 없을까 고민을 계속 해봐야겠다.

---

## 3주차 과제(자판기)

3주차 과제는 자판기에서 음료수를 사먹는 과정을 코드로 작성하는 것 이었다. 아래는 코드를 구현하면서 신경을 썼던 사항들을 정리했다.



1. 일급 컬렉션의 활용
2. 기능 목록
3. 프로그램

---

### 1. 일급 컬렉션의 활용

2주차때 처음으로 일급 컬렉션을 사용해봤다. Cars 클래스를 만들어서 경주가 진행되고, 우승자를 찾는 과정을 직관적인 메서드로 설계할 수 있었고 Controller가 하나의 책임을 가질 수 있도록 설계하는데 도움을 주었다.

이번에는 일급 컬렉션의 갯수가 훨씬 늘어났다. Coin Enum을 사용해야 하는데 자판기안에 있는 동전들을 관리하기 위해서 Coins라는 `List<Coin>` 일급 컬렉션을 만들어 자판기의 동전과 관련된 메서드를 정리했고,

Item,Items 일급 컬렉션을 만들어 등록되는 상품들과 자판기 안에 들어있는 상품의 갯수를 관리해줬다.

```java
public class Coins {
	private LinkedHashMap<Coin, Integer> coins;

	public void makeCoins(int money) {
		List<Integer> coinType = getCoinType();
		setCoinsMap();
		while (money != 0) {
			int randomCoin = Randoms.pickNumberInList(coinType);
			if (money - randomCoin >= 0) {
				money -= randomCoin;
				addCoin(randomCoin);
			}
		}
	}
  
  public class Machine {
  
  private final int money
	private Coins coins;

	public void makeCoins() {
		coins.makeCoins(money);
	}
```

위와 같이 코드를 작성하게 되면 Controller 단에서는

`machine.makeCoins()` 라는 표현만 보여지게 되서, 직관적으로 이 메서드는 코인을 만드는 기능을 한다고 이해할 수 있다. 2주차때는 일급 컬렉션이 마치 장애물처럼 느껴졌는데, 익숙해지니 전체적인 구조가 한눈에 쉽게 들어오게 되었다.

---

### 2. 기능 목록

2주차 피드백에 1번 항목이 기능목록 작성에 관한 내용이었다. 요약하자면 너무 구체적으로 작성하지 말고, 정상적인 작동과정과는 별개로 예외사항들에 대한 정리도 필요하다는 것 이었다.

피드백을 보고나서 1,2주차 때 작성한 기능목록들을 봤는데, 마치 나의 기능목록을 보시고 하시는 말 같았다. 나는 기능목록을 작성하는데 시간을 많이 들였었는데, 입력 받아야할 값과, 출력값, 예외사항에 대해 구체적으로 설명을 하려다 보니 기능 목록이 복잡하게 작성됐었다.

```markdown
6. 최종 우승자를 출력한다.

>`조건` : 등록된 우승자가 한명 이상일 경우 쉼표(,)로 나누어 출력한다.
>
>`출력` 
>
>1. 우승자가 한 명일 경우 : "최종 우승자 : pobi"
>
>2. 우승자가 두 명 이상일 경우 : "최종 우승자 : pobi, jun"
```

위 예시 처럼 전체적인 흐름과 그에 맞는 조건, 출력문을 한 공간에 작성하다보니 시간도 오래걸리고, 전반적인 클래스 구조에 대해서 전부 생각을 했어야 했다.

피드백을 받고, 보내주신 예시를 기반으로 생각을 해봤는데 기능 목록은 전반적인 흐름을 담고 있으며 살아있는 문서의 역할을 한다면 굳이 처음부터 모든 기능을 세세하게 작성하면서 시간을 들일 필요가 없었다.

```markdown
6.최대 위치값을 갖고있는 자동차 목록을 구한다.
```

이 정도로 끝날 수 있는 부분이었다. 그래서 3주차 기능 목록을 작성할 때는 최대한 간결하고 시간을 너무 많이 할애하지 않으려고 했다. 전반적인 큰 흐름을 작성하고 당시 생각나는 예외사항들만 적어둔 뒤 구현을 하면서 찾은 부분들을 나중에 보완해주면서 진행했다.

---

### 3. 프로그램

1주차 때는 함수의 분리, 2주차는 클래스의 분리, 그리고 마지막 과제의 목표는 

`여러 개의 클래스를 분리한 후 서로 관계를 맺어 하나의 프로그램을 완성하는 경험을 하는 것,`

단계별로 올라가는 이런 과정이 성장을 하고싶어하는 나에게 너무 도움이 됐다. 다른 분들이 PR 보내신 코드들을 많이 읽어봤는데 1주차부터 완벽해보이는 코드들이 너무 많아서 코드를 읽어보는 연습을 했다. 아무래도 내가 구현을 해봤던 내용을 읽으니까 수월하게 읽을 수 있었고 배울점들이 너무 많았다. 패키지 구조에 대해서 고민을 했었는데, 제출해주신 분들이 MVC 패턴을 써서 처리하고, 도메인에 메서드를 넣어서 깔끔하게 구현을 하는 방식을 보고 감탄을 했었다. 매주 과제가 끝나고 좋아보이는 구조들은 카피해서 개인적으로 연습하면서 구현을 해봤고 3주차 때는 나도 그런 분들과 비슷하게 구조를 짜고 도메인에 기능을 넣어서 일급 컬렉션을 만들 수 있게 되었다. 그래서 3주차 목표를 수행하는데 도움이 많이 되었다.

---

## 4. 프리코스를 마치면서

​	벌써 3주가 지났다는게 믿기지 않을정도로 시간이 빨리 지나갔다. 평일에 짬짬이 시간을 내면서 코드를 작성하고, 주말에 완성을 해서 제출을 했었는데 바쁘지만 너무 행복했다. 매주 수요일마다 미션을 진행하기 전에 기능목록을 작성하면서 설렜다. 어떻게하면 기능을 깔끔하게 구현할 수 있을까 깨끗한 코드를 작성하기 위해 노력했고 책을 읽어보면서 생각을 정리할 수 있는 시간을 보냈다. 내가 도달할 수 있는 목표를 보여주고 단계를 올려가면서 성장할 수 있는 원동력을 받은 것 같아서 너무 행복한 시간들을 보낼 수 있었던 것 같다.

​	개인적으로 아쉬운 것은 1,2주차가 3기와 같은 문제가 나왔다는 것이다. Console, Randoms 라이브러리를 통해서 내가 작성한 코드가 요구사항에 맞는지 확인할 수 있도록 변경된 점은 너무 좋았지만, 미리 1,2주차를 진행해봐서 그런지 3주차보다는 설레임이 덜했던 것 같다. 지원자마다 실력이 달라서 사전 준비를 통해 부족한 점들을 채우고 진행하라는 배려일지도 모르겠다. 같은 내용을 다루되 조건을 조금 달리해서 바꿔보는 것도 좋은 아이디어가 아닐까 생각된다.

  최근에 '함께 자라기' 라는 책을 읽었는데 저자는 경력과 실력의 연관성은 떨어진다는 말을 한다. 2년차 개발자가 10년차 개발자보다 잘할수도 있다는 말이다. 보통 우리는 그 분야에 종사한 시간이 많으면 장인이라는 호칭을 붙인다. 게임에서도 한 캐릭터를 몇천판 이상한 사람을 장인이라고 부른다, 티어에 상관없이. 하지만 실력이 있는 사람은 항상 시간을 많이 투자한게 아닐수도 있다는 말이다. 저자는 실력을 기르기 위해서 제자리 걸음하는 시간을 줄이고 불안함과 지루함의 경계속에 자신을 밀어넣고 고민을 해결하면서 성장해야한다고 말한다.

  우아한 테크코스의 커리큘럼은 아마 이러한 점들을 많이 고려하고 만들어졌다고 느껴졌다. 고작 3주밖에 진행하지 않았지만, 프로젝트를 진행할 때보다 훨씬 코드의 질에 신경을 써서 만들었다. 함수의 기능이 한가지인지, 클래스는 단일 책임 원칙을 지키고 있는지등 지속적으로 나를 불편하게 만드는 조건들을 통해서 나를 불안함의 경계로 밀어주었다. 그래서 3주동안 많이 성장할 수 있었던 것 같다.

  이제 최종 테스트를 앞두고 있는데, 5시간 동안 구현해야한다는 점이 살짝 부담이다. 빠릿빠릿한 사람은 아니라서 느긋하게 고민하는 것을 좋아하는데 최종 테스트때는 디테일 보다는 기능구현에 집중해서 구현을 한뒤 디테일을 신경써보려고 한다. 어떤 결과가 나올지는 모르겠지만 프리코스는 나에게 정말 값진 기회였음은 확실하고, 이어서 테크코스까지 진행해서 내 자신을 성장시키는 2022년을 보내고 싶다.





