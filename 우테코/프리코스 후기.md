# 우아한 테크코스 프리코스 회고

1. 과정소개, 자소서 합격 후기
2. 시작전 나의 실력
3. 임하는 태도 및 상황

1. 1주차
2. 2주차
3. 3주차
4. 최종 정리



## 1. 과정 소개

프리코스는 우아한 테크코스를 진행하기에 앞서 자격을 확인하기 위한 과정이다. 1차 심사 자기소개서와 코딩테스트를 통과해야지 참가할 수 있다. 3기 기준으로 대략 1천명이 지원했다고 했는데, 4기는 아직 전체 지원자수는 모르지만 현재 프리코스를 진행중인 백엔드 지원자들은 160명 가량된다. 선발 인원이 100명이므로 대략 1.6:1의 경쟁률이다.

3주 동안 총 3개의 과제가 나오고 매주 수요일 15시부터 일주일동안 구현해서 제출하면 된다. 매주 미션이 시작될 때 메일을 통해서 제출이 잘 됐는지 확인해주고 공통 피드백을 보내준다. 매주 미션의 난이도가 어려워지고, 조건들이 추가된다.



## 2. 프리코스 이전 나의 상태

중학교 학생들을 대상으로 수학 수업을 구성하다 코딩에 흥미가 생겨서 개발자를 준비하게 되었고, 인공지능 국비교육을 수료한 뒤 백엔드에 흥미가 생겨서 Java와 Spring 공부를 1년정도 했다. 주로 인프런과 유튜브의 강의를 통해서 학습을 했고 Spring, JPA는 인프런에서 김영한 님 로드맵을 전부 수강했다. 객체 지향에 대해 공부하기 위해서 객체 지향에 대한 사실과 오해, TDD 책을 읽었고 NextStep PlayGround 과정을 통해 TDD 맛봤다. 프론트엔드 개발자인 친구와 TodoList 프로젝트를 진행하고, 중고 책 거래하는 사이트를 만들어보기 위해서 공부중인 상태에서 지원하게 되었다.

Java를 정통으로 공부한게 아니라, 필요할 때 마다 구글링해가면서 학습했기 때문에 자신은 없었다. 1차 심사를 합격하고 나서 프리코스 1주차 문제를 구현해보려고 했는데 막막했었다. 함수를 어떻게 분리해야할지 감이 잘 안왔고, 클래스도 분리할 줄 몰랐다. 근데 코딩테스트를 준비하기 위해서 Java로 알고리즘 연습을 꾸준히 해왔기 때문에 Java가 완전 낯선상태는 아니었다.



---

## 미션(1주차~3주차)

### 0주차(준비)

1차 심사 결과 메일을 받고나서, 프리코스를 진행하는 목적과 사전준비 라는 메일을 받았다.

![스크린샷 2021-12-12 오전 1.27.10](/Users/hyuntae/Desktop/스크린샷 2021-12-12 오전 1.27.10.png)

설레었다, 뭔가 프리코스가 본격적으로 시작되는 것 같은 기분을 받았다.

미션을 시작하기 전에 매우 설레는 상태로 과제에 임했다. 1차 심사에 합격을 하고나서 1주차 문제를 구현해봤다. 처음에는 알고리즘 풀듯이 main 메서드 안에 모든 기능을 구현했다. 돌이켜 생각해보면 3 주 동안 큰변화가 있었다.

### 1주차 과제(숫자 야구)

1주차 과제는 숫자 야구를 구현하는 과제였다. 주어진 미션은 함수를 분리해서 한가지 기능을 할 수 있도록 구현하는 것이었다. 아래는 구현하면서 고민했던 사항들을 정리해놨다.

---

1. 패키지 구조
2. 예외 처리
3. 클린코드?

---

#### 1. 패키지 구조

숫자야구 프로젝트를 진행하고 다른 분들의 코드를 읽어보다 패키지 구조를 어떻게 가져가는게 좋을까하는 고민을 하게되었다. 나는 기본적인 구조에서 constant 패키지만 생성해서 에러메시지와 입출력 메시지를 관리하는 Message클래스와 입력하는 숫자의 범위와 길이 등 규칙을 관리하는 Rule 클래스를 넣어두었다.

```
├─main
│  └─java
│      ├─baseball
│      └─constant
└─test
    └─java
        └─baseball
```

하지만 참가자들중 MVC 패턴을 이용해서 controller,domain,view 를 나누어서 진행하신 분들도 있었고 기능별로 나눠서 설계하신분도 있었다. 개인적으로 프로젝트 규모가 크지 않아서 굳이 나눠야하나 생각했는데 막상 나눠진 것을 봤을 때 깔끔하다는 생각이 들었다. 효율적인 구조에 대해 고민을 하다 구글링을 통해 패키지 구조에 대한 공부를 했다.

---

패키지 구조는 크게 계층 우선 구조, 모듈 우선 구조 두 가지로 나눌 수 있다.

##### 계층(layer) 우선

```java
net.slipp.domain.modulename
net.slipp.service.modulename
net.slipp.dao.modulename
net.slipp.web.modulename
```

특징: 도메인 모델 주도 개발에 적합하다.

장점: 각 패키지간의 cyclic dependency



##### 모듈(feature) 우선

```java
net.slipp.modulename.domain
net.slipp.modulename.service
net.slipp.modulename.dao
net.slipp.modulename.web
```

특징: 개발자별로 기능 단위 개발을 하는 경우 주로 발생한다.

장점: 모듈 단위로 분리할 때 유리하다.

---

찾아본 결과 정답은 없고 각자의 취향 혹은 팀원들의 규칙에 따라 가는 것 같다.

하지만 미션으로 나오는 과제들은 구현해야할 기능이 많지 않기 때문에 모듈 우선 구조로 설계하게되면 필요 이상으로 패키지가 많이 생기게된다. 따라서 계층 우선 구조로 설계를 하기로 결정하는게 좋을 것 같다.

MVC 패턴에 대해서 조금 생각해봐야겠다. 1주차는 구현해야 할 기능에 비해 구조가 과하다고 생각했는데 2주차 과제부터 도메인이 많아지거나 구조가 복잡해진다면 도입해볼 생각이다.

참고:

https://slipp.net/questions/36

 http://www.javapractices.com/topic/TopicAction.do?Id=205



#### 2. 예외처리

```java
public class Validation {
	public static void checkRestartInput(String request) {
		if (!request.equals("1") && !request.equals("2")) {
			throw new IllegalArgumentException(ERROR_REQUEST_INPUT);
		}
	}
```

위 코드는 1주차 숫자야구 미션에서 재시작 입력값을 예외처리한 메서드다.

>  "재시작을 원한다면 1을 입력하고, 종료를 원한다면 2를 입력해라."

불만족스러웠지만 다른 방법이 생각이 안나서 우선 1,2를 제외한 입력을 받았을 때  `IllegalArgumentException` 를 발생시키는 방법을 택했다. 그리고 클린코드 7장. 오류 처리를 통해 오류 코드보다는 예외를 사용하라는 도움을 받아 2주차 부터는 try-catch 구문으로 오류를 처리해보려고 한다.

#### 3. 클린코드?

큰 고민 사항은 위 두 항목이었지만, 사실 코드를 짜는 모든 과정에서 고민이 생겼다. 어떻게 하면 더 쉽게 읽힐 수 있을까? 어떻게 하면 구조가 한눈에 들어올까 고민을 했다. 도움을 얻기 위해 클린코드 책에서 필요한 부분들을 찾아서 읽고, 구조에 대한 고민이 시작됐다. 한 주 동안 코드를 모르는 사람이 봐도 내 코드를 이해할 수 있도록 간단하게 구현하려고 노력했고 매일매일 나아지는 것을 느꼈다. 클린코드를 읽으며 예외처리, 변수명에 대해서 고민했고, 함수가 한가지의 기능에 책임질 수 있도록 설계하려고 했다.

> 소프트웨어를 짜는 행위는 여느 글짓기와 비슷하다. 먼저 생각을 기록한 후 읽기 좋게 다듬는다. 초안은 대개 서투르고 어수선하므로 원하는 대로 읽힐 때까지 말을 다듬고 문장을 고치고 문단을 정리한다.

이 말이 나에게 와닿았다. 첫 과제라 기능 구현에서 큰 어려움은 없었지만 가독성이 있는 코드를 작성하기 위해 노력했다.

---

## 2주차 과제 (자동차 경주)

2주차 과제는 자동차 경주 게임 구현이었다. 주어진 미션은 클래스 분리였다. 아래는 구현하면서 고민했던 사항들이다.

---

1. 클래스 분리와 함수 분리
2. 예외 처리
3. 메세지, 상수
4. 책임에 대하여

---

## 1. 클래스 분리와 함수 분리

1주차를 마치고 같이 제출하신 분들의 코드를 읽어보았다. 구현을 해본 코드라서 다른 분들의 코드를 이해하기 쉬웠다. 정말 배울점이 많았고 그 중에 바로 도입해야겠다고 생각한 것이 패키지의 구조였다. 클린코드의 함수와 객체 부분을 읽으며 얼마나 분리해야하나 고민을 했는데, 답을 구할 수 있었다.

> 함수는 한 가지를 해야 한다. 그 한 가지를 잘해야 한다. 그 한가지 만을 해야한다.

최대한 작게 만들고 함수가 하나의 기능만을 하도록 만들라고 하였고, 이 말은 즉 단 한개의 책임을 가져야한다는 말이다. 책임이라는 말이 애매하기 때문에 저자는 변경이 있을 때 파급 효과가 적도록 구현하라고 하였다.

SOLID의 제일 앞글자를 담당하는 Single Responsibility Principle(단일 책임 원칙) 을 지키며 구현하는 것이 나의 2주차 목표였다.

처음 난간에 봉착한 것은 자동차 이름 입력값을 검증하는 과정에서 였다. 

> 1. 입력값을 받는다.
> 2. 입력값이 조건에 부합한지 판단한다.
> 3. 조건에 부합하면 `ArrayList<String>` 를 반환한다.

Controller 에서 이 3가지 기능이 한번에 움직이길 바랐다. 그러다 보니 처음 구현을 했을 때 책임이 중구난방 뒤섞여있었다. 그런데 클린코드에서 변수명을 잘 지으면 문제를 해결할 실마리가 보인다해서 고민을 했다.

결과적으로, 나는 getProperName 이라는 함수명을 통해 검증은 nameValidator에게 책임을 위임하고 입력값을 갖고오는 책임을 InputView에 부여하고 Controller에게는 입력값에 관해 받아오기만 하면 되도록 설계했다.

클래스를 잘 분리하기 위해서 MVC 패턴을 도입해보려고 노력하고, 클래스 이름을 잘 지어보려고 했다. 처음에는 CarService를 이용해서 각 경기를 진행하고, 자동차 등록, 우승자를 찾아내는 기능들을 관리했었다. 하지만 조금 더 깔끔하게 관리를 하고 싶어서 찾아보다가 일급 클래스에 대해 찾아보게 되었다.

바로 이거다 싶어서 Cars 라는 객체를 만들고 경주에 관련된 메서드를 관리하도록 만들었더니 Controller에서 더 명확하게 어떤 일을 하는지 확인할 수 있었다.

reference:

https://jojoldu.tistory.com/412

---

## 2. 예외 처리

예외 처리에 관련된 부분도 클린코드에서 도움을 받을 수 있었다.

1주차에는 needBalls 라는 `boolean` 값을 flag 값으로 사용해서 while-do 구문을 이용했다. 그런데 이보다 try-catch 구문을 쓰는게 더 명확하고 깔끔하다는 내용을 보았다.

그래서 2주차에서는 예외처리를 validation 클래스를 생성하여 `boolean` 값을 return 하는 것이 아니라 예외를 발생시키고 예외를 InputView클래스에서 catch 해서 풀어갈 수 있도록 구현해보았다.

```java
public void validateNames(ArrayList<String> names) {
		isOnlyName(names);
    	...
	}

	private void isOnlyName(ArrayList<String> names) {
		if (names.size() == 1) {
			throw new IllegalArgumentException(ERROR_ONLY_NAME);
		}
	}
```

---

## 3. 메세지 상수 처리

1주차 때는 constant 패키지를 만들어서 오류 메세지, 출력 메세지, 상수를 한꺼번에 관리하는 클래스를 만들었었다. 다른 분들은 view 클래스를 만들어서 한번에 입출력을 관리하도록 구현했는데 이 방식이 깔끔해보였다. 메세지도 상단에서 바로 확인할 수 있고 입력과 출력을 클래스를 통해 구분할 수 있어서 좋아보였다.

상수를 따로 분리하는 것도 나쁘지는 않다고 생각하는데, 이번에는 입출력을 관리하는 클래스를 만들어서 구현하기로 했다.

----

## 4. 책임에 대하여

구현을 마치고 계속 리팩토링하면서 책임에 대한 부분이 고민이 많이 됐다. 단일 책임 원칙을 지키고 싶은데, 책임이라는 말도 모호하고 한가지라고 보는 관점이 다를 수 있어서 클린코드의 클래스, 함수 챕터를 여러번 반복해서 읽었다. 최대한 의미있게 클래스를 분리하고 싶어서 각 클래스가 하나의 책임을 가질 수 있도록 설계했다.

```
Car : 도메인 자동차 객체
CarService : 자동차 객체의 로직
RaceController : 애플리케이션 흐름 제어
InputView : 입력 관리
OutputView : 출력 관리
NameValidator : 이름 목록 검증
MoveCountValidator : 이동 횟수 검증
```

작성을 하고보니 CarService의 책임이 하나 이상이라고 봐야하나 의문이 든다. Controller와 Service를 조금 더 깔끔하게 구분하고 싶은데 아직까지는 방법을 잘 모르겠다. Car 객체를 다루는 방법도 서툴고 getter를 만들어서 접근할 수 있도록 만들기보다 좀 더 나은 방법은 없을까 고민을 계속 해봐야겠다.

---

## 3주차 과제(자판기)







