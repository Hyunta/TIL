# 1. MVCC와 언두로그 리두 로그

- 레코드 수준의 트랜잭션을 지원하기 위해서 InnoDB는 MVCC를 사용한다.
- 스냅샷을 통해서 하나의 레코드에 대한 여러 버전을 관리한다
- 동시성 제어시 락을 사용하지 않기 위해서 사용한다.
- MySQL은 MVCC를 언두로그를 통해서 활용한다.



## Undo Log

트랜잭션과 격리 수준을 보장하기 위해 백업해둔 변경 전의 데이터

- 트랜잭션 보장: 트랜잭션이 롤백되면 변경된 데이터를 백업된 이전 버전으로 복구한다
- 격리 수준 보장: 특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면 격리 수준에 맞는 데이털르 반환



데이터베이스는 커밋 여부와 무관하게 실제 데이터와 메모리의 내용을 변경한다. 그리고 언두 영역에는 변경전의 값을 백업해두다가 커밋되면 현재 상태를 유지하고 롤백되면 백업 데이터로 복구한다.

- 대량의 데이터를 변경하는 경우
- 트랜잭션을 오래 유지하는 경우

그러므로 트랜잭션은 가능한 짧게 유지히는 것이 좋다.



## Redo Log

D와 가장 밀접하게 연관돼있다. 데이터 변경 내용을 redo log로 기록 하고 비정상적으로 종료됐을 때 일관된 데이터를 갖도록 도와준다.

- 커밋됐지만 데이터 파일에 기록되지 않은 데이터
- 롤백됐지만 데이터 파일에 이미 기록된 데이터

이런 문제가 발생했을 때 리두 로그 내용을 복사하기만 하면 된다.



## 버퍼풀

스토리지 엔진의 핵심 부분으로 디스크에 저장된 테이블과 인덱스 정보를 캐시해두는공간이다.

- 캐싱을 통한 읽기 성능 향상
- 쓰기 지연을 통한 쓰기 성능 향상

데이터를 임시 저장하기 위한 메모리 공간이므로, 읽기 작업 시에 디스크 읽기 횟수를 줄여 성능을 높일 수 있다. 성능에 상당항 영향을 준다. MySQL 5.6부터는 서버가 셧다운 되기 직전에 버퍼풀을 백업하고, 자동으로 복구할 수 있는 기능을 제공한다. warming up



## 잠금 없는 일관된 읽기

MySQL은 MVCC를 통해 락 없이 읽기 작업을 수행할 수 있다. 격리수준이  SERIALIZABLE만 아니라면 순수한 읽기 작업은 트랜잭션과 무관하게 항상 잠금 대기 없이 실행된다. 이는 언두 로그를 통해서 가능한다.

read-commited 이상일 경우 -> 언두 로그의 값을 읽어온다.

repeatable read에서 phantom read가 발생하지 않는 이유는 InnoDB가 첫 조회시 만든 snapshot을 기반으로 결과를 반환하기 때문이다.



