# 2장. 코틀린 기초

2장에서 다루는 내용은

- 함수, 변수, 클래스, enum, property 선언 방법
- 제어 구조
- 스마트 캐스트
- throw-catch 예외

코틀린은 자바와 제어구조가 유사하지만 중요한 개선사항이 있다.



# 2.1 기본 요소: 함수와 변수

```kotlin
fun main(args: Array<Sring>) {
    println("Hello, world!")
}
```

- 함수를 선언할 때 fun을 사용한다.
- 파라미터 이름 뒤에 타입을 쓴다. 변수를 선언할 때도 마찬가지로 지정한다.
- 함수를 최상위 수준에 정의할 수 있다. (자바에서는 클래스 안에 함수가 있어야 한다)
- 코틑린에는 자바와 달리 배열 처리를 위한 문법이 없다.
- 코틀린 표준 라이브러리는 여러가지 표준 자바 라이브러리를 간결하게 사용할 수 있게 래퍼를 제공한다.(여기서는 println)
- 줄 끝에 세미콜론을 붙이지 않아도 된다.



## 2.1.2 함수

값을 반환하는 함수의 경우 반환 값의 타입을 어디에 지정해야 할까?

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/eb82a3f1-3ec0-4d8c-8c13-416e19938f2c/Untitled.png)

코틀린에서 if는 expression이지 statement가 아니다.

expression: 값을 만들고 다른 식의 하위 요소로 계산에 참여할 수 있다

statement: 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하고 아무런 값을 만들어내지 않는다.

Java는 모든 제어 구조가 statement이지만 코틀린은 루프를 제외한 대부분의 제어구조가 expression이다.

코틀린은 식이 본문인 함수가 자주 쓰인다.

```kotlin
fun max(a: Int, b: Int) = if (a > b) a else b
```

코틀린은 타입추론을 지원한다. 사용자가 함수의 반환 타입을 적지 않아도, 컴파일러가 함수 본문 식을 분석해서 식의 결과 타입을 함수 반환 타입으로 정해준다.



## 2.1.3 변수

코틀린은 타입 지정을 생략하는 경우가 흔하다. 타입으로 변수 선언을 시작하면 타입을 생략할 경우 식과 변수 선언을 구별할 수 없다. 그런 이유로 코틀린에서는 키워드로 변수 선언을 시작하는 대신 변수 이름 뒤에 타입을 명시하거나 생략하게 허용한다.

val: immutable한 참조를 저장하는 변수다. 초기화하고 나면 재대입이 불가능하다. 자바에서의 final

var: mutable한 참조다. 변수 값은 바뀔 수 있다.

기본적으로 모든 변수를 val로 선언하고, 나중에 꼭 필요할 때만 var로 변경하라.

val은 블록을 실행할 때 정확히 한 번만 초기화돼야 한다. 조건에 따라 val 값을 다른 여러값으로 초기화할 수도 있다.

```kotlin
val message: String
if (canPerformOperation()) {
		message = "Success"
		//... 연산을 수행한다. 
} else {
	message = "Failed"
}
```

val 참조 자체는 불변이어도, 참조가 가리키는 객체의 내부 값은 변경될 수 있다.



## 2.1.4 문자열 템플릿

```kotlin
val name = "Bob"
println("Hello, $name!")
```

$ 기호를 통해 문자열 접합 연산을 사용한 식과 마찬가지로 구성할 수 있다. 만약 name이라는 변수가 존재하지 않으면 컴파일 에러가 발생한다. $ 기호를 넣고 싶다면 “\$” 와 같이 \를 통해 출력할 수 있다.

만약 한글을 입력하고 싶거나 리스트의 원소를 대입하고 싶다면 `${name}` 처럼 중괄호를 입력하면 가능합니다. 만약 한글을 대입하는 경우 한글까지 한번에 식별자로 인식해서 unresolved reference 오류를 발생시킵니다.