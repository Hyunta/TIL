# 설계 목표

유일한 ID를 설계할 때 보통 DB의 Auto Increment 속성을 써서 RDBMS에서 제공하는 기본 키를 썼습니다. 하지만 만약 분산환경에서 구축해야한다면 여러 데이터베이스를 사용하기 때문에 유일성을 보장받지 못합니다. 어떻게하면 유일성을 보장하면서 분산환경에서 아이디를 구축할 수 있을지 고민해봅시다.



# 대략적인 설계안

1. ID는 유일해야 한다.
2. ID는 숫자로만 구성되어야 한다.
3. ID는 64비트로 표현될 수 있는 값이어야 한다.
4. ID는 발급 날짜에 따라 정렬 가능해야 한다.
5. 초당 10,000개의 ID를 만들 수 있어야 한다.



# 설계 방향



## 1. 다중 마스터 복제

auto_increment 기능을 활용하여 다음 ID의 값을 구할 때 K만큼 증가시킨다. (K = 데이터베이스 수)

<문제점>

- 여러 데이터 센터에 규모를 늘리기 어렵다
- 시간 흐름에 맞추어 커지도록 보장할 수 없다.
- 서버를 추가하거나 삭제할 때 문제가 발생할 수 있다.



## 2. UUID

UUID는 128비트짜리 수로, 충돌 가능성이 지극히 낮다. 서버간 독립적으로 생성하더라도 문제가 발생하지 않는다. 따라서 동기화 문제도 발생하지 않고, 규모 확장도 쉽다.

<문제점>

- ID가 128비트로 너무 길다.
- 시간순으로 정렬할 수 없다.
- 숫자가 아닌 값이 포함될 수 있다.



## 3. 타겟 서버

타겟 서버를 중앙 집중형으로 하나만 사용하는 것이다.

<문제점>

- 타겟 서버가 SPOF가 된다.
- 분산을 시키면 동기화 문제가 발생한다.



## 4. 트위터 스노플레이크 접근법

ID 구조를 원하는 섹션으로 분할하는 것이다.

| 섹션          | 비트 | 내용                                                         |
| ------------- | ---- | ------------------------------------------------------------ |
| 사인          | 1    | 나중에 부호 용도로 사용하든, 추후 사용할 수 있도록 자리를 마련해둔다. |
| 타임스탬프    | 41   | 특정 시간을 기준점으로 잡고 그 이후 흘러간 밀리세컨으로 표현한다. 2^41-1은 대략 20억초로 약 70년에 해당한다. |
| 데이터센터 ID | 5    | 데이터 센터 32개 지원                                        |
| 서버 ID       | 5    | 서버 32개 지원                                               |
| 일련번호      | 12   | 1밀리초가 경과할 때 리셋시켜준다. 최대 4000개 가량 생성 가능 |

초당 10000개가 생성되더라도 타임스탬프와 일련번호로 중복을 방지할 수 있다.

타임스탬프로 발급날짜에 따라 정렬이 가능하다.

다만, 2^41-1 70년동안만 정상작동한다. 70년이 지나면 ID 체계를 바꾸거나 다른것으로 이전해야 한다.

동시성 문제가 과하지 않다면 일련번호 값을 줄이고 타임스탬프를 늘리는 것이 나을 수도 있다.

